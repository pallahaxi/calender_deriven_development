'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/opt_100/test/',title:"Testページ",section:"Opt 100",content:"Juliaで数理最適化のコンテンツ追加方法 #  ページの作り方\nhugo new docs/opt_100/mogamoga.md 上記で content/docs/opt_100/mogamoga.md が作成される。これを編集する。\n"}),a.add({id:1,href:'/docs/opt_100/graph/',title:"グラフの最短経路問題",section:"Opt 100",content:"グラフの最短経路を探すお #  using LightGraphs, SimpleWeightedGraphs, GraphPlot, Cairo, GraphRecipes, Compose, Colors function ordered_edges(graph::LightGraphs.AbstractGraph) edge_dict = Dict{Tuple{Int,Real}, Any}() for e in edges(graph) edge_dict[(src(e), dst(e))] = e end return values(sort(edge_dict)) end function generate_grid(node_num_array::Union{Tuple{Int,Real},Array{Int,1}}, random_range::Union{UnitRange{\u0026lt;:Real}, Array{\u0026lt;:Real,1}}=1:10, plot_flag::Bool=false, file_name::String=\u0026#34;grid.png\u0026#34;) @assert length(node_num_array) == 2 grid_graph = grid(node_num_array) # gridでエッジを構築 g = SimpleWeightedGraph(nv(grid_graph)) # 重み付きエッジのグラフをgrid_graphのノードの個数構築 edge_weight = rand(random_range, grid_graph.ne) # 予め乱数でエッジの重みを作成 for (num, e) in enumerate(edges(grid_graph)) add_edge!(g, e.src, e.dst, edge_weight[num]) end locs_x = Array{Float64, 1}( vcat([i for i in 1:node_num_array[1], j in 1:node_num_array[2]]...)) locs_y = Array{Float64, 1}( vcat([j for i in 1:node_num_array[1], j in 1:node_num_array[2]]...)) if plot_flag draw( PNG(file_name, 10cm, 10cm), gplot(SimpleGraph(g), # weightgraphは直接gplotに渡せない locs_x, locs_y, nodelabel=1:nv(g), # collect(edges(g))の順序とplotの順序は対応していないので注意 # edgeのlabel orderはlexicographic orderingに従うhttps://github.com/JuliaGraphs/GraphPlot.jl/issues/70 edgelabel=[e.weight for e in ordered_edges(g)]) ) end return g end function grid_yen_shortest_path(graph::LightGraphs.AbstractGraph, node_num_array::Union{Tuple{Int,Real},Array{Int,1}}, source::Int, target::Int, plot_flag::Bool=false, file_name::String=\u0026#34;grid_shortest_path.png\u0026#34;) @assert length(node_num_array) == 2 shortest_path = yen_k_shortest_paths(graph, source, target) dists = shortest_path.dists[1]; # 複数ある可能性があるが、一旦1番目のものだけ paths = shortest_path.paths[1]; # 複数ある可能性があるが、一旦1番目のものだけ locs_x = Array{Float64, 1}( vcat([i for i in 1:node_num_array[1], j in 1:node_num_array[2]]...)) locs_y = Array{Float64, 1}( vcat([j for i in 1:node_num_array[1], j in 1:node_num_array[2]]...)) colors = [colorant\u0026#34;lightgray\u0026#34; for i in 1:ne(graph)]; node_piar = Vector{Tuple}(undef, length(paths) - 1); for (num, (i, j)) in enumerate(zip(paths[begin:end-1], paths[begin+1:end])) node_piar[num] = (i, j) end for (num, e) in enumerate(ordered_edges(graph)) if (src(e), dst(e)) in node_piar colors[num] = colorant\u0026#34;orange\u0026#34; end end if plot_flag draw( PNG(file_name, 10cm, 10cm), gplot(SimpleGraph(graph), locs_x, locs_y, nodelabel=1:prod(node_num_array), edgestrokec=colors, edgelabel=[e.weight for e in ordered_edges(graph)]) ) end end const node_num_array = [7, 7] g = generate_grid(node_num_array, 1:10, true); grid_yen_shortest_path(g, node_num_array, 1, nv(g), true) \u0026#34;\u0026#34;\u0026#34; 最短経路を探索する関数はあるものの、下記に対応する全pathを列挙する関数はなさそう? GraphSet.set_universe(G.edges()) paths = GraphSet.paths(terminal1=(0,0), terminal2=(n-1,n-1)) len(paths) #パスの総数 count =0 for p in paths.min_iter(weight): count+=1 if count\u0026gt;=10: break print(p) plt.figure() nx.draw(G, pos=pos,with_labels=False, node_size=100) nx.draw(G, pos=pos,with_labels=False, node_size=100, edgelist=p,edge_color=\u0026#34;red\u0026#34;,width=10,alpha=0.3) nx.draw_networkx_edge_labels(G,pos,edge_labels=weight) plt.show() 参考 https://juliagraphs.org/LightGraphs.jl/latest/pathing/#Path-discovery-/-enumeration all_simple_pathsが実装されれば対応する処理ができると思われる。 https://github.com/JuliaGraphs/LightGraphs.jl/pull/1540 function all_paths_count(g::AbstractGraph, source::Int) c = 0 for i in 1:nv(g) if source == i continue end c += length(all_simple_paths(g, source, i)) end return c / 2 end 的な 最長経路も同様 \u0026#34;\u0026#34;\u0026#34; function generate_random_complete_graph(n::Int, plot_flag::Bool=false, file_name::String=\u0026#34;random_complete_graph.png\u0026#34;) x = Dict(i =\u0026gt; 100*rand(Float64) for i in 1:n) y = Dict(i =\u0026gt; 100*rand(Float64) for i in 1:n) G = SimpleWeightedGraph(n) for i in 1:n p₁ = Point(x[i], y[i]) for j in 1:n p₂ = Point(x[j], y[j]) if j \u0026gt; i d = distance(p₁, p₂) add_edge!(G, i, j, d) end end end locs_x = collect(values(x)) locs_y = collect(values(y)) if plot_flag draw( PNG(file_name, 10cm, 10cm), gplot(SimpleGraph(G), # weightgraphは直接gplotに渡せない locs_x, locs_y, nodelabel=1:nv(G)) ) end return G, locs_x, locs_y end struct Point x::Float64 y::Float64 end function distance(p₁::Point, p₂::Point) sqrt((p₁.x - p₂.x)^2 + (p₁.y - p₂.y)^2) end G, locs_x, locs_y = generate_random_complete_graph(10, true) function detect_cycle(g::AbstractGraph, source::Int, len::Int) [i for i in simplecycles_limited_length(g, len) if length(i) \u0026gt; len-1 \u0026amp;\u0026amp; i[1] == source] end function cycle_plot(G::AbstractGraph, source::Int, len::Int, locs_x::Vector, locs_y::Vector, file_name::String=\u0026#34;cycle_plot.png\u0026#34;) paths = detect_cycle(G, source, len) path = paths[rand(1:length(paths))] # 1つサンプル node_piar = Vector{Tuple}(undef, length(path)); for (num, (i, j)) in enumerate(zip(path[begin:end-1], path[begin+1:end])) node_piar[num] = Tuple(sort([i, j])) end node_piar[end] = (path[begin], path[end]) colors = [colorant\u0026#34;lightgray\u0026#34; for i in 1:ne(G)]; for (num, e) in enumerate(ordered_edges(G)) if (src(e), dst(e)) in node_piar colors[num] = colorant\u0026#34;orange\u0026#34; end end draw( PNG(file_name, 10cm, 10cm), gplot(SimpleGraph(G), # weightgraphは直接gplotに渡せない locs_x, locs_y, edgestrokec=colors, nodelabel=1:nv(G)) ) end cycle_plot(G, 1, 4, locs_x, locs_y) \u0026#34;\u0026#34;\u0026#34; Hamilton閉路もないっす。 \u0026#34;\u0026#34;\u0026#34; "}),a.add({id:2,href:'/docs/opt_100/',title:"Opt 100",section:"Docs",content:"Juliaで数理最適化 100問 #  Juliaで数理最適化100問を再構成する。\nTable of Contents #    Testページ   その他テストページ   グラフの最短経路問題   Lightgraph.jl の使い方   "}),a.add({id:3,href:'/docs/jump/mogamoga/',title:"Mogamoga",section:"JuMPチュートリアル",content:"test\n"}),a.add({id:4,href:'/docs/jump/',title:"JuMPチュートリアル",section:"Docs",content:"JuMP.jl の使い方 #  Juliaの数理最適化ページ以外に JuMP.jl のチュートリアルについても進めたい。\nTable of Contents #    Mogamoga   test   "})})()