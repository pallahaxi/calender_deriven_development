'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/jump/getting_started_w_jump/',title:"Getting Started W Jump",section:"JuMPチュートリアル",content:"JuMPのチュートリアルGetting started with JuMPを見ながら簡単なビンパッキング問題を解いたものを紹介します。該当ページとは異なる内容となりますが、Pythonの PuLP と比較しながら行います。\n線形計画問題 #  まず非常に簡単な線形計画問題を1つ解いてみます。次の問題を考えます。\n PuLP (Python) #  import pulp as pp # モデル定義 model = pp.LpProblem(name='reidai', sense=pp.LpMaximize) # 決定変数を定義 x1 = pp.LpVariable(name='x1', lowBound=0, upBound=None, cat='Continuous') x2 = pp.LpVariable(name='x2', lowBound=0, upBound=None, cat='Continuous') # 目的関数を実装 model += 3*x1 + 2*x2 # 制約条件 model += 2*x1 + 5*x2 \u0026lt;= 500 model += 4*x1 + 2*x2 \u0026lt;= 300 # 解を求める model.solve() print(f\u0026quot;x1={x1.value()}, x2={x2.value()}\u0026quot;) print(f\u0026quot;売上={model.objective.value()}\u0026quot;)  結果はこのようになります。  JuMP (Julia) #  ここではソルバーとして GLPK パッケージの GLPK.Optimizer を使います。制約条件に名前をつけることが可能で、それぞれ c1, c2 とします。\nusing JuMP using GLPK # モデル定義 model = Model(GLPK.Optimizer) # 決定変数を定義 @variable(model, x1 \u0026gt;= 0) @variable(model, x2 \u0026gt;= 0) # 目的関数を実装 @objective(model, Max, 3x1 + 2x2) # 制約条件 @constraint(model, c1, 2x1 + 5x2 \u0026lt;= 500) @constraint(model, c2, 4x1 + 2x2 \u0026lt;= 300) # 解を求める optimize!(model) @show value(x1) @show value(x2) @show objective_value(model)  ちなみに、 print(model) でモデルとして設定した情報を見ることができます。  結果はこの通りです。  ビンパッキング問題(整数計画問題) #   問題文：\n 重さが   \\(w_i (i=1~10)\\)  のアイテムが10個ある。これを最大10個の箱の中に詰め込むことを考えたい。1つの箱には10kgまでしかアイテムが詰められない時、使用する箱の数を最小にするアイテムの組み合わせと、使用した箱の数を求めよ。\n この時  \\(y_i = {0,1}\\)  がi番目の箱を使用したか否か、  \\(x_{ij} = {0,1}\\)  がi番目の箱にj番目のアイテムを入れたか否か、という2値変数になります。 線形計画問題の例題と異なり、決定変数が行列で表記されています。私がJuliaで好きな点として、数式で書かれているものをそのまま(とまでは言いませんが)プログラムとして記述できるという特徴があるのですが、このような問題が与えられたときに、Pythonと比較してコードの形に翻訳する努力が少なくて済みます。 逆に言えば、この辺りをすぐにコードとしてイメージできる人からすると、Juliaに違和感を感じるところなのかもしれません。\nPuLP (Python) #  model2 = pp.LpProblem(name='bin_packing', sense=pp.LpMinimize) N_PRODUCT = 10 N_BOX = 10 # 決定変数 x = pp.LpVariable.dicts('x', [(i,j) for i in range(N_BOX) for j in range(N_PRODUCT)], cat='Binary') y = pp.LpVariable.dicts('y', range(N_BOX), cat='Binary') weight = [3,5,7,4,8,8,6,9,6,5] # 目的関数 model2 += pp.lpSum(y[i] for i in range(N_BOX)) # 制約条件 for i in range(N_BOX): model2 += pp.lpSum(x[(i,j)]*weight[j] for j in range(N_PRODUCT)) \u0026lt;= 10*y[i] for j in range(N_PRODUCT): model2 += pp.lpSum(x[(i,j)] for i in range(N_BOX)) == 1 model2.solve() for key in x.keys(): if x[key].value() == 1: print(f\u0026quot;x{key}:{x[key].value()}\u0026quot;) print(f\u0026quot;y = {[y[i].value() for i in range(N_BOX)]}\u0026quot;) print(f\u0026quot;Objective value = {model2.objective.value()}\u0026quot;)   どの箱を選ぶか、というところに不定性はあると思いますが、同一の箱に詰め込むアイテムの組み合わせと7個の箱を使用する、という最小値が求まりました。\nJuMP (Julia) #  using JuMP using GLPK # モデル定義 model2 = Model(GLPK.Optimizer) # 定数 const N_PRODUCT = 10 const N_BOX = 10 const weight = [3,5,7,4,8,8,6,9,6,5] # 決定変数を定義 @variable(model2, x[1:N_BOX, 1:N_PRODUCT], Bin) @variable(model2, y[1:N_BOX], Bin) # 目的関数を実装 @objective(model2, Min, sum(y)) # 制約条件 @constraint(model2, x * weight .\u0026lt;= 10y) @constraint(model2, sum(x, dims=1) .== 1) # dims=1 で行列xᵢⱼ のiについて和を取る # 解を求める optimize!(model2) @show findall(value.(x) .== 1.0) @show value.(y) @show objective_value(model2)  Pythonとの大きな違いは次の2つかと思います。\n 決定変数を定義 Pythonでは行列の変数をタプル (i,j) を key とした辞書として作成しましたが、Juliaでは行列を変数として扱うことができます。 制約条件 Juliaでは連立不等式を行列とベクトルの積として表すことができ、数式からのコーディングを直感的に行うことができます。  結果を見てみます。行列の全成分を見るのは大変なので、 x の値が1になる成分を呼び出してみます。  次に y の成分を確認します。  数えてみると、使われた箱の数が7個であることがわかります。\n箱の中に1つだけ入っているものはどうでもいいとして、同一の箱に入った組み合わせをPython、Juliaそれぞれで確認してみると、\n Python  箱2:(1,9) 箱3:(3,8) 箱4:(0,2)   Julia  箱3:(4,9) 箱4:(1,3) 箱8:(2,10)    となりました。Juliaの方は番号が0からではなく1から開始することを考慮すると、きちんと一致していることがわかります。\n"}),a.add({id:1,href:'/docs/jump/n_queens/',title:"N-Queens",section:"JuMPチュートリアル",content:"Nクイーン問題 #  Originally Contributed by: Matthew Helm\nNクイーン問題とは、   \\(N \\times N\\)  マスのチェス盤にN個のクイーンをお互いに取ることがでないよう配置する問題です。 例えば以下の図のような配置は4クイーン問題の解になります。  JuMPチュートリアルより転載   チェスのクイーンは縦方向、横方向、斜め方向にどこまでも進むことが可能です。 そのため、この問題では与えられた盤面の各行、各列、各斜め列に1つのクイーンしか置くことができません。\nそれでは、実際のチェス盤と同様に  \\(8 \\times 8 \\)  について8クイーン問題を解いてみましょう。  \\( 8 \\times 8 \\)  行列を考えて、この行列の各成分をチェス盤に対応させます。 成分が1のときそのマスにはクイーンが置かれてある状態、0のときは駒がない状態を表すことで、この問題は整数計画問題となります。\nusing JuMP import GLPK import LinearAlgebra # 8-Queens N = 8 model = Model(GLPK.Optimizer) 変数を定義します。 上で述べたように変数はバイナリ値をとる  \\( 8 \\times 8 \\)  行列 x です。\n@variable(model, x[1:N, 1:N], Bin)  制約条件を与えます。各行・各列には1つのクイーンしか置けないので、\n# 各行・列でクイーンが唯一つ存在する for i in 1:N @constraint(model, sum(x[i,:]) == 1) @constraint(model, sum(x[:,i]) == 1) end また、各斜め方向にも1つのクイーンしか置けないので、\n# 任意の斜線にクイーンが唯一つ存在する for i in -(N-1):(N-1) @constraint(model, sum(LinearAlgebra.diag(x,i)) \u0026lt;= 1) @constraint(model, sum(LinearAlgebra.diag(reverse(x, dims = 1), i)) \u0026lt;= 1) end 制約条件はこれだけなので、解を求めます。\noptimize!(model) 得られた解を見てみます。\nsolution = convert.(Int, value.(x))  この解をチェス盤で表示するとこれに対応します。  JuMPチュートリアルより転載   8クイーン問題には92種類の異なる解が存在します(らしいです)。 再び解を optimize! で求め直すと別の解が得られます。\n "}),a.add({id:2,href:'/docs/jump/the_Diet_problem/',title:"The Diet Problem",section:"JuMPチュートリアル",content:"本記事は、JuMPのチュートリアルThe diet problemを解説したものです。\nオリジナルのチュートリアルには解説がないため、解説は当サイトが加えたものとなります。\nThe Diet Problem #  古典的な「栄養問題（diet problem; Stigler diet）」を解きます。 栄養問題は、全米研究評議会の定める食事摂取量基準を満たしつつ、最小限のコストとなる食事の組み合わせを求めるという、線形最適化問題の代表例です。\nこの問題の詳細や歴史的背景についてはWikipediaに詳しい記載があります。 このチュートリアルで用いるデータ・解法はGurobiでの例をベースとしています。 コードの全容はこちら(GitHub)にあります。以降、コードを適宜抜粋しながら解説します。\nまず、栄養基準を category_data に用意します。摂取すべき4つの栄養（カロリー、タンパク質、脂質、塩分）の上限値・下限値を定めています。\n例えば、タンパク質の摂取下限は91.0、塩分の摂取上限は1779.0です。\n値の確認にTestパッケージを使っていますが、説明は省略します。\n ここで利用しているContainers.DenseAxisArrayは、JuMPで利用できるデータ配列です。\nJulia標準の配列やDataFramesのデータフレームを用いることもできますが、チュートリアルに従いContainersを利用します。\nDenseAxisArrayの引数には、順にデータ、第1軸（行）の軸ラベル、第2軸（列）の軸ラベルを与えており、データの呼び出しを容易にしています。\n続いて、9種の食品の価格と栄養成分を用意します。 costに費用を、food_dataに栄養素を定義しています。\n 必要なデータが用意できたところで、モデルの構築に移ります。\nサンプルコードの通り、@variablesマクロを用いることで複数の変数を同時に定義できます。 決定変数として、栄養の下限・上限を満たす値が入るnutritionと、どの食事を購入するかのbuyを用意します。\n コストの最小化が目的となるため、それに合致した目的関数を定義します。\n それぞれの栄養素が基準値の範囲内かどうかという制約を加えます。\n 複数のカテゴリに対する制約を一度に定義しています。\n第2引数にカテゴリ（= c）のリスト、第3引数にそのカテゴリ内での栄養素の合計がnutritionと同じになるというように表現しています。\ncategory_data[c, \u0026quot;min\u0026quot;] \u0026lt;= sum(food_data[f, c] * buy[f] for f in foods) \u0026lt;= category_data[c, \u0026quot;max\u0026quot;] と同等の制約になります。\nモデルの定義は以上です。モデルを求解するにはoptimize関数を利用します。\n モデルが解を得られたかどうかは、モデルのステータスから確認できます。\nステータスはtermination_statu\u0008s関数で確認することができ、解を得られている場合はスクリプトで別に定義しているprint_solution関数で表示できます。\nステータスの判定にMOIを利用しています。これはJuMPに含まれているMathOptInterfaceパッケージのオブジェクトです。 MathOptInterfaceは、数学的最適化ソルバーのための標準化されたAPIを提供します。JuMPのステータスもこれに従っているため、解が得られた（MOI.OPTIMAL）かどうかを判定することができます。\n原題を求解中... 結果: hamburger = 0.6045138888888888 chicken = 0.0 hot dog = 0.0 fries = 0.0 macaroni = 0.0 pizza = 0.0 salad = 0.0 milk = 6.9701388888888935 ice cream = 2.591319444444441 それぞれのカテゴリについて、摂取量が表示されています。\nほとんど牛乳から栄養を摂取すべき、という結果が得られていることがわかるかと思います。\nそこで、乳製品（牛乳・アイスクリーム）の摂取量に制約を加えて再度求解してみましょう。\n 乳製品の制約を加えた問題を求解中... 結果: ソルバーは最適解を見つけられませんでした。 こちらは解を見つけられませんでした。用意された食事では、栄養のほとんどを牛乳で賄う必要があるようですね。\n"}),a.add({id:3,href:'/docs/jump/Sudoku/',title:"Sudoku",section:"JuMPチュートリアル",content:"数独 #  Originally Contributed by: Iain Dunning\n有名な数字のパズルとして数独があります。数独では3x3の9マスの中に下記のルールに従って1~9の数字を埋めていくパズルです。\n 3x3の正方マスで1~9の数字を必ず1回登場させます 各行で1~9の数字を必ず1回登場させます 各列で1~9の数字を必ず1回登場させます  本チュートリアルでは下記の数独を解きます  JuMPチュートリアルより転載   正確には数独は目的関数を最適化する問題ではなく、Feasibility Problemと呼ばれる問題になります。 具体的には今回の問題は全ての変数を0-1のバイナリ値として記述し、整数問題として解くことができます。 整数問題のソルバーを用いてJuMPのモデルを構築していきましょう。\nusing JuMP using GLPK モデルを作成します。\nsudoku = Model(GLPK.Optimizer) 本問題の変数を定義します。 上記の通り、バイナリ変数(0 or 1)を用意します。 cell(i,j)が数値kを持っているを持っているときに x[i,j,k] = 1 をアサインするように設計します。 ここで i は行を、 j は列を指すインデックスです。 このような設計を JuMP では下記のように作成することができます。\n@variable(sudoku, x[i=1:9, j=1:9, k=1:9], Bin) 9×9×9 Array{VariableRef,3}: [:, :, 1] = x[1,1,1] x[1,2,1] x[1,3,1] x[1,4,1] x[1,5,1] x[1,6,1] x[1,7,1] x[1,8,1] x[1,9,1] x[2,1,1] x[2,2,1] x[2,3,1] x[2,4,1] x[2,5,1] x[2,6,1] x[2,7,1] x[2,8,1] x[2,9,1] x[3,1,1] x[3,2,1] x[3,3,1] x[3,4,1] x[3,5,1] x[3,6,1] x[3,7,1] x[3,8,1] x[3,9,1] x[4,1,1] x[4,2,1] x[4,3,1] x[4,4,1] x[4,5,1] x[4,6,1] x[4,7,1] x[4,8,1] x[4,9,1] x[5,1,1] x[5,2,1] x[5,3,1] x[5,4,1] x[5,5,1] x[5,6,1] x[5,7,1] x[5,8,1] x[5,9,1] x[6,1,1] x[6,2,1] x[6,3,1] x[6,4,1] x[6,5,1] x[6,6,1] x[6,7,1] x[6,8,1] x[6,9,1] x[7,1,1] x[7,2,1] x[7,3,1] x[7,4,1] x[7,5,1] x[7,6,1] x[7,7,1] x[7,8,1] x[7,9,1] x[8,1,1] x[8,2,1] x[8,3,1] x[8,4,1] x[8,5,1] x[8,6,1] x[8,7,1] x[8,8,1] x[8,9,1] x[9,1,1] x[9,2,1] x[9,3,1] x[9,4,1] x[9,5,1] x[9,6,1] x[9,7,1] x[9,8,1] x[9,9,1] [:, :, 2] = x[1,1,2] x[1,2,2] x[1,3,2] x[1,4,2] x[1,5,2] x[1,6,2] x[1,7,2] x[1,8,2] x[1,9,2] x[2,1,2] x[2,2,2] x[2,3,2] x[2,4,2] x[2,5,2] x[2,6,2] x[2,7,2] x[2,8,2] x[2,9,2] x[3,1,2] x[3,2,2] x[3,3,2] x[3,4,2] x[3,5,2] x[3,6,2] x[3,7,2] x[3,8,2] x[3,9,2] x[4,1,2] x[4,2,2] x[4,3,2] x[4,4,2] x[4,5,2] x[4,6,2] x[4,7,2] x[4,8,2] x[4,9,2] x[5,1,2] x[5,2,2] x[5,3,2] x[5,4,2] x[5,5,2] x[5,6,2] x[5,7,2] x[5,8,2] x[5,9,2] x[6,1,2] x[6,2,2] x[6,3,2] x[6,4,2] x[6,5,2] x[6,6,2] x[6,7,2] x[6,8,2] x[6,9,2] x[7,1,2] x[7,2,2] x[7,3,2] x[7,4,2] x[7,5,2] x[7,6,2] x[7,7,2] x[7,8,2] x[7,9,2] x[8,1,2] x[8,2,2] x[8,3,2] x[8,4,2] x[8,5,2] x[8,6,2] x[8,7,2] x[8,8,2] x[8,9,2] x[9,1,2] x[9,2,2] x[9,3,2] x[9,4,2] x[9,5,2] x[9,6,2] x[9,7,2] x[9,8,2] x[9,9,2] [:, :, 3] = x[1,1,3] x[1,2,3] x[1,3,3] x[1,4,3] x[1,5,3] x[1,6,3] x[1,7,3] x[1,8,3] x[1,9,3] x[2,1,3] x[2,2,3] x[2,3,3] x[2,4,3] x[2,5,3] x[2,6,3] x[2,7,3] x[2,8,3] x[2,9,3] x[3,1,3] x[3,2,3] x[3,3,3] x[3,4,3] x[3,5,3] x[3,6,3] x[3,7,3] x[3,8,3] x[3,9,3] x[4,1,3] x[4,2,3] x[4,3,3] x[4,4,3] x[4,5,3] x[4,6,3] x[4,7,3] x[4,8,3] x[4,9,3] x[5,1,3] x[5,2,3] x[5,3,3] x[5,4,3] x[5,5,3] x[5,6,3] x[5,7,3] x[5,8,3] x[5,9,3] x[6,1,3] x[6,2,3] x[6,3,3] x[6,4,3] x[6,5,3] x[6,6,3] x[6,7,3] x[6,8,3] x[6,9,3] x[7,1,3] x[7,2,3] x[7,3,3] x[7,4,3] x[7,5,3] x[7,6,3] x[7,7,3] x[7,8,3] x[7,9,3] x[8,1,3] x[8,2,3] x[8,3,3] x[8,4,3] x[8,5,3] x[8,6,3] x[8,7,3] x[8,8,3] x[8,9,3] x[9,1,3] x[9,2,3] x[9,3,3] x[9,4,3] x[9,5,3] x[9,6,3] x[9,7,3] x[9,8,3] x[9,9,3] [:, :, 4] = x[1,1,4] x[1,2,4] x[1,3,4] x[1,4,4] x[1,5,4] x[1,6,4] x[1,7,4] x[1,8,4] x[1,9,4] x[2,1,4] x[2,2,4] x[2,3,4] x[2,4,4] x[2,5,4] x[2,6,4] x[2,7,4] x[2,8,4] x[2,9,4] x[3,1,4] x[3,2,4] x[3,3,4] x[3,4,4] x[3,5,4] x[3,6,4] x[3,7,4] x[3,8,4] x[3,9,4] x[4,1,4] x[4,2,4] x[4,3,4] x[4,4,4] x[4,5,4] x[4,6,4] x[4,7,4] x[4,8,4] x[4,9,4] x[5,1,4] x[5,2,4] x[5,3,4] x[5,4,4] x[5,5,4] x[5,6,4] x[5,7,4] x[5,8,4] x[5,9,4] x[6,1,4] x[6,2,4] x[6,3,4] x[6,4,4] x[6,5,4] x[6,6,4] x[6,7,4] x[6,8,4] x[6,9,4] x[7,1,4] x[7,2,4] x[7,3,4] x[7,4,4] x[7,5,4] x[7,6,4] x[7,7,4] x[7,8,4] x[7,9,4] x[8,1,4] x[8,2,4] x[8,3,4] x[8,4,4] x[8,5,4] x[8,6,4] x[8,7,4] x[8,8,4] x[8,9,4] x[9,1,4] x[9,2,4] x[9,3,4] x[9,4,4] x[9,5,4] x[9,6,4] x[9,7,4] x[9,8,4] x[9,9,4] [:, :, 5] = x[1,1,5] x[1,2,5] x[1,3,5] x[1,4,5] x[1,5,5] x[1,6,5] x[1,7,5] x[1,8,5] x[1,9,5] x[2,1,5] x[2,2,5] x[2,3,5] x[2,4,5] x[2,5,5] x[2,6,5] x[2,7,5] x[2,8,5] x[2,9,5] x[3,1,5] x[3,2,5] x[3,3,5] x[3,4,5] x[3,5,5] x[3,6,5] x[3,7,5] x[3,8,5] x[3,9,5] x[4,1,5] x[4,2,5] x[4,3,5] x[4,4,5] x[4,5,5] x[4,6,5] x[4,7,5] x[4,8,5] x[4,9,5] x[5,1,5] x[5,2,5] x[5,3,5] x[5,4,5] x[5,5,5] x[5,6,5] x[5,7,5] x[5,8,5] x[5,9,5] x[6,1,5] x[6,2,5] x[6,3,5] x[6,4,5] x[6,5,5] x[6,6,5] x[6,7,5] x[6,8,5] x[6,9,5] x[7,1,5] x[7,2,5] x[7,3,5] x[7,4,5] x[7,5,5] x[7,6,5] x[7,7,5] x[7,8,5] x[7,9,5] x[8,1,5] x[8,2,5] x[8,3,5] x[8,4,5] x[8,5,5] x[8,6,5] x[8,7,5] x[8,8,5] x[8,9,5] x[9,1,5] x[9,2,5] x[9,3,5] x[9,4,5] x[9,5,5] x[9,6,5] x[9,7,5] x[9,8,5] x[9,9,5] [:, :, 6] = x[1,1,6] x[1,2,6] x[1,3,6] x[1,4,6] x[1,5,6] x[1,6,6] x[1,7,6] x[1,8,6] x[1,9,6] x[2,1,6] x[2,2,6] x[2,3,6] x[2,4,6] x[2,5,6] x[2,6,6] x[2,7,6] x[2,8,6] x[2,9,6] x[3,1,6] x[3,2,6] x[3,3,6] x[3,4,6] x[3,5,6] x[3,6,6] x[3,7,6] x[3,8,6] x[3,9,6] x[4,1,6] x[4,2,6] x[4,3,6] x[4,4,6] x[4,5,6] x[4,6,6] x[4,7,6] x[4,8,6] x[4,9,6] x[5,1,6] x[5,2,6] x[5,3,6] x[5,4,6] x[5,5,6] x[5,6,6] x[5,7,6] x[5,8,6] x[5,9,6] x[6,1,6] x[6,2,6] x[6,3,6] x[6,4,6] x[6,5,6] x[6,6,6] x[6,7,6] x[6,8,6] x[6,9,6] x[7,1,6] x[7,2,6] x[7,3,6] x[7,4,6] x[7,5,6] x[7,6,6] x[7,7,6] x[7,8,6] x[7,9,6] x[8,1,6] x[8,2,6] x[8,3,6] x[8,4,6] x[8,5,6] x[8,6,6] x[8,7,6] x[8,8,6] x[8,9,6] x[9,1,6] x[9,2,6] x[9,3,6] x[9,4,6] x[9,5,6] x[9,6,6] x[9,7,6] x[9,8,6] x[9,9,6] [:, :, 7] = x[1,1,7] x[1,2,7] x[1,3,7] x[1,4,7] x[1,5,7] x[1,6,7] x[1,7,7] x[1,8,7] x[1,9,7] x[2,1,7] x[2,2,7] x[2,3,7] x[2,4,7] x[2,5,7] x[2,6,7] x[2,7,7] x[2,8,7] x[2,9,7] x[3,1,7] x[3,2,7] x[3,3,7] x[3,4,7] x[3,5,7] x[3,6,7] x[3,7,7] x[3,8,7] x[3,9,7] x[4,1,7] x[4,2,7] x[4,3,7] x[4,4,7] x[4,5,7] x[4,6,7] x[4,7,7] x[4,8,7] x[4,9,7] x[5,1,7] x[5,2,7] x[5,3,7] x[5,4,7] x[5,5,7] x[5,6,7] x[5,7,7] x[5,8,7] x[5,9,7] x[6,1,7] x[6,2,7] x[6,3,7] x[6,4,7] x[6,5,7] x[6,6,7] x[6,7,7] x[6,8,7] x[6,9,7] x[7,1,7] x[7,2,7] x[7,3,7] x[7,4,7] x[7,5,7] x[7,6,7] x[7,7,7] x[7,8,7] x[7,9,7] x[8,1,7] x[8,2,7] x[8,3,7] x[8,4,7] x[8,5,7] x[8,6,7] x[8,7,7] x[8,8,7] x[8,9,7] x[9,1,7] x[9,2,7] x[9,3,7] x[9,4,7] x[9,5,7] x[9,6,7] x[9,7,7] x[9,8,7] x[9,9,7] [:, :, 8] = x[1,1,8] x[1,2,8] x[1,3,8] x[1,4,8] x[1,5,8] x[1,6,8] x[1,7,8] x[1,8,8] x[1,9,8] x[2,1,8] x[2,2,8] x[2,3,8] x[2,4,8] x[2,5,8] x[2,6,8] x[2,7,8] x[2,8,8] x[2,9,8] x[3,1,8] x[3,2,8] x[3,3,8] x[3,4,8] x[3,5,8] x[3,6,8] x[3,7,8] x[3,8,8] x[3,9,8] x[4,1,8] x[4,2,8] x[4,3,8] x[4,4,8] x[4,5,8] x[4,6,8] x[4,7,8] x[4,8,8] x[4,9,8] x[5,1,8] x[5,2,8] x[5,3,8] x[5,4,8] x[5,5,8] x[5,6,8] x[5,7,8] x[5,8,8] x[5,9,8] x[6,1,8] x[6,2,8] x[6,3,8] x[6,4,8] x[6,5,8] x[6,6,8] x[6,7,8] x[6,8,8] x[6,9,8] x[7,1,8] x[7,2,8] x[7,3,8] x[7,4,8] x[7,5,8] x[7,6,8] x[7,7,8] x[7,8,8] x[7,9,8] x[8,1,8] x[8,2,8] x[8,3,8] x[8,4,8] x[8,5,8] x[8,6,8] x[8,7,8] x[8,8,8] x[8,9,8] x[9,1,8] x[9,2,8] x[9,3,8] x[9,4,8] x[9,5,8] x[9,6,8] x[9,7,8] x[9,8,8] x[9,9,8] [:, :, 9] = x[1,1,9] x[1,2,9] x[1,3,9] x[1,4,9] x[1,5,9] x[1,6,9] x[1,7,9] x[1,8,9] x[1,9,9] x[2,1,9] x[2,2,9] x[2,3,9] x[2,4,9] x[2,5,9] x[2,6,9] x[2,7,9] x[2,8,9] x[2,9,9] x[3,1,9] x[3,2,9] x[3,3,9] x[3,4,9] x[3,5,9] x[3,6,9] x[3,7,9] x[3,8,9] x[3,9,9] x[4,1,9] x[4,2,9] x[4,3,9] x[4,4,9] x[4,5,9] x[4,6,9] x[4,7,9] x[4,8,9] x[4,9,9] x[5,1,9] x[5,2,9] x[5,3,9] x[5,4,9] x[5,5,9] x[5,6,9] x[5,7,9] x[5,8,9] x[5,9,9] x[6,1,9] x[6,2,9] x[6,3,9] x[6,4,9] x[6,5,9] x[6,6,9] x[6,7,9] x[6,8,9] x[6,9,9] x[7,1,9] x[7,2,9] x[7,3,9] x[7,4,9] x[7,5,9] x[7,6,9] x[7,7,9] x[7,8,9] x[7,9,9] x[8,1,9] x[8,2,9] x[8,3,9] x[8,4,9] x[8,5,9] x[8,6,9] x[8,7,9] x[8,8,9] x[8,9,9] x[9,1,9] x[9,2,9] x[9,3,9] x[9,4,9] x[9,5,9] x[9,6,9] x[9,7,9] x[9,8,9] x[9,9,9] 上記ルールに基づき変数に条件を課します。まずは下記のコードのようにして「各セル(i, j)に必ず1つの数字を埋める」という条件を課します。 言い換えれば「   \\(\\sum_k x_{i,j,k} == 1\\)  になるように制約をつける」ということになります。\nfor i = 1:9 ## For each row for j = 1:9 ## and each column ## Sum across all the possible digits. One and only one of the digits ## can be in this cell, so the sum must be equal to one. @constraint(sudoku, sum(x[i, j, k] for k = 1:9) == 1) end end 次に各行と各列に数独のルールに則って条件を課します。 冒頭で述べた条件2, 3のように各行と各列のに1回ずつ1~9の数字を登場させます。 コード上での制限の付け方は先ほどの例と非常によく似ています。\nfor ind = 1:9 ## Each row, OR each column for k = 1:9 ## Each digit ## Sum across columns (j) - row constraint @constraint(sudoku, sum(x[ind, j, k] for j = 1:9) == 1) ## Sum across rows (i) - column constraint @constraint(sudoku, sum(x[i, ind, k] for i = 1:9) == 1) end end さらに各サブグリッド(小さい3x3のマス)に1回ずつ1~9の数字を登場させる条件を課します。 今回のコードでは左上のサブグリッドから順に行と列それぞれ for ループを用いてアクセスし、サブグリッド内で各kについての総和を1にします。\nfor i = 1:3:7 for j = 1:3:7 for k = 1:9 ## i is the top left row, j is the top left column. ## We\u0026#39;ll sum from i to i+2, e.g. i=4, r=4, 5, 6. @constraint( sudoku, sum(x[r, c, k] for r in i:(i+2), c in j:(j+2)) == 1 ) end end end 以上で制約条件の設定は終わりです。\n最後に既知の初期値を設定します。 上記の写真のように初期値を埋めるのですが、初期値が与えられていないマスについては一旦 0 を置いておき、 if 文を用いて初期値の設定をしないよう処理をします。\ninit_sol = [ 5 3 0 0 7 0 0 0 0 6 0 0 1 9 5 0 0 0 0 9 8 0 0 0 0 6 0 8 0 0 0 6 0 0 0 3 4 0 0 8 0 3 0 0 1 7 0 0 0 2 0 0 0 6 0 6 0 0 0 0 2 8 0 0 0 0 4 1 9 0 0 5 0 0 0 0 8 0 0 7 9 ] for i = 1:9 for j = 1:9 ## If the space isn\u0026#39;t empty if init_sol[i, j] != 0 ## Then the corresponding variable for that digit and location must ## be 1. fix(x[i, j, init_sol[i, j]], 1; force = true) end end end 以上でモデルの設定が全て終わりました。\n設定されたモデルの最適化を実行します。\noptimize!(sudoku) 最適化された変数を抜き出して見てみます。\nx_val = value.(x) 9×9×9 Array{Float64,3}: [:, :, 1] = 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 [:, :, 2] = 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 [:, :, 3] = 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [:, :, 4] = 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [:, :, 5] = 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 [:, :, 6] = 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 [:, :, 7] = 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 [:, :, 8] = 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 [:, :, 9] = 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 上記のままでは少々わかりにくいので、行列を作成し数値を埋め込みます。\nsol = zeros(Int, 9, 9) # 9x9 matrix of integers for i = 1:9 for j = 1:9 for k = 1:9 ## Integer programs are solved as a series of linear programs so the ## values might not be precisely 0 and 1. We can just round them to ## the nearest integer to make it easier. if round(Int, x_val[i, j, k]) == 1 sol[i, j] = k end end end end 解を確認します。\nsol 9×9 Array{Int64,2}: 5 3 4 6 7 8 9 1 2 6 7 2 1 9 5 3 4 8 1 9 8 3 4 2 5 6 7 8 5 9 7 6 1 4 2 3 4 2 6 8 5 3 7 9 1 7 1 3 9 2 4 8 5 6 9 6 1 5 3 7 2 8 4 2 8 7 4 1 9 6 3 5 3 4 5 2 8 6 1 7 9 解を図示したものが下記になります。  JuMPチュートリアルより転載   "}),a.add({id:4,href:'/docs/jump/Rocket_Control/',title:"Rocket Control",section:"JuMPチュートリアル",content:"Rocket Control #  Originally Contributed by: Iain Dunning\n本チュートリアルでは非線形最適化を用いてロケット制御問題をどのように解くかを解説します。 この「ロケット制御問題」はCOPS3の10章にある「Goddard Rocket」として紹介されている問題と同じパラメータを利用します。\n本問題のゴールは「垂直に打ち上げられたロケットの最高高度を最大化」することです。\n本チュートリアルの設定ではコントロール可能な1パラメータとして「ロケットの推進力」があり、ロケットの質量・燃料の消費量(消費率)・重力・空気抵抗などを考慮しつつ最高高度の最大化を目指します。\nロケット制御に含まれるパラメータや詳細についてはCPOS3のPDFを参照してください。\nOverview #  ロケット制御のモデル化を記述するにあたり、刻々と変化する時間を固定値   \\(n\\)  で離散化させタイムステップとして取り扱います。\nつまり離散化する固定値  \\(n\\)  と観測する最終時間  \\(t_f\\)  を用いることで、  \\(t_f = n \\cdot \\Delta t\\)  と記述します。\nState and Control #  ロケットの状態を記載するため下記の3つの変数を導入します。\n  \\(v\\)  : 速度  \\(h\\)  : 高度  \\(m\\)  : ロケットと残燃料を合わせた質量  また本チュートリアルでコントロール可能な1パラメータである推進力を  \\(T\\)  とします。\nさらに本問題で最大化したい高度を  \\(h(t_f)\\)  とします。\nDynamics #  ロケット制御を考える上で力学で用いる運動方程式から、下記の3方程式を得ます。\n 上昇率:  \\(h^\\prime = v\\)   加速度:  \\(v^\\prime = \\frac{T - D(h,v)}{m} - g(h)\\)   質量の変化率:  \\(m^\\prime = -\\frac{T}{c}\\)    チュートリアルでは上記について説明が少なく、不親切だと思ったので補足します。\n今回鉛直上向きの1軸しか考えず、上昇率は鉛直上向きの単位時間あたりの移動距離を指すのでロケットの速度に他なりません。\n加速度については高校物理で習う運動方程式  \\(ma = F\\)  から得られます。ロケットに作用する力は鉛直上向きにロケット自身の推進力  \\(T\\)  が存在し、鉛直下向きに質量と重力加速度  \\(g(h)\\)  の積で得られる重力  \\(mg(h)\\)  と空気抵抗  \\(D(h, v)\\)  が存在します。つまり高校物理で習う運動方程式に合わせて記述すると  \\(m v^\\prime = T - D(h, v) - mg(h)\\)  となります。ここで  \\(g(h)\\)  が高度  \\(h\\)  に依存するのは地球から離れるため重力加速度が小さくなるためです。また  \\(D(h, v)\\)  は速度  \\(v\\)  に依存するのは高校物理で習う通りで、高度  \\(h\\)  に依存するのは高所では空気が薄くなるためです。\n最後の方程式では今回  \\(c\\)  を定数として最適化問題を解きます。つまり質量の変化率はロケットの推進力が比例関係にあることを指しており、質量と速度が同時に変化するロケットのような系を考えると自然と得られます。\nまたここで導入した空気抵抗  \\(D(h, v)\\)  と重力加速度  \\(g(h)\\)  は下記の式に従います。  \\[\\begin{aligned} D(h,v) \u0026amp;= D_c v^2 \\exp\\left[ -h_c \\left( \\frac{h-h(0)}{h(0)} \\right) \\right],\\\\ g(h) \u0026amp;= g_0 \\left( \\frac{h(0)}{h} \\right)^2 \\end{aligned}\\]  地上での重力加速度  \\(g_0\\)  と高度の初期値  \\(h(0)\\)  と  \\(D_c, h_c\\)  は定数として扱われます。\n実際にコーディングに移ります。\nusing JuMP import Ipopt import Plots それぞれパッケージのバージョンは\nIpopt v0.6.5 JuMP v0.21.8 Plots v1.14.0 を利用しています。\nソルバーとしてIpoptを使用し、JuMPのモデルを作成します。\nrocket = Model(Ipopt.Optimizer) set_silent(rocket) Constants #   \\(h(0) = m(0) = g_0 = 1\\)  の単位系をとることでこれまでの定式化の物理量を全て無次元に整理することができます。 今回はそれぞれ全パラメータにCOPS3の数値を用います。\nh_0 = 1 # Initial height v_0 = 0 # Initial velocity m_0 = 1 # Initial mass g_0 = 1 # Gravity at the surface T_c = 3.5 # Used for thrust h_c = 500 # Used for drag v_c = 620 # Used for drag m_c = 0.6 # Fraction of initial mass left at end c = 0.5 * sqrt(g_0 * h_0) # Thrust-to-fuel mass m_f = m_c * m_0 # Final mass D_c = 0.5 * v_c * m_0 / g_0 # Drag scaling T_max = T_c * g_0 * m_0 # Maximum thrust n = 800 # Time steps Decision variables #  本問題での変数の定義域を定義します。\n@variables(rocket, begin Δt ≥ 0, (start = 1/n) # Time step # State variables v[1:n] ≥ 0 # Velocity h[1:n] ≥ h_0 # Height m_f ≤ m[1:n] ≤ m_0 # Mass # Control variables 0 ≤ T[1:n] ≤ T_max # Thrust end) Objective #  本問題の目的変数は高度  \\(h\\)  の最大化であり、下記のように設定します。\n@objective(rocket, Max, h[n]) Initial conditions #  fix(v[1], v_0; force = true) fix(h[1], h_0; force = true) fix(m[1], m_0; force = true) fix(m[n], m_f; force = true) Forces #  @NLexpressions(rocket, begin # Drag(h,v) = Dc v^2 exp( -hc * (h - h0) / h0 ) drag[j = 1:n], D_c * (v[j]^2) * exp(-h_c * (h[j] - h_0) / h_0) # Grav(h) = go * (h0 / h)^2 grav[j = 1:n], g_0 * (h_0 / h[j])^2 # Time of flight t_f, Δt * n end) Dynamics #  上記で導入した方程式を各タイムステップでの制約式として扱います。具体的には台形法を用いて各タイムステップで積分した式を制約式とします。\nfor j in 2:n # h\u0026#39; = v # Rectangular integration # @NLconstraint(rocket, h[j] == h[j - 1] + Δt * v[j - 1]) # Trapezoidal integration @NLconstraint(rocket, h[j] == h[j - 1] + 0.5 * Δt * (v[j] + v[j - 1])) # v\u0026#39; = (T-D(h,v))/m - g(h) # Rectangular integration # @NLconstraint( # rocket, # v[j] == v[j - 1] + Δt *((T[j - 1] - drag[j - 1]) / m[j - 1] - grav[j - 1]) # ) # Trapezoidal integration @NLconstraint( rocket, v[j] == v[j-1] + 0.5 * Δt * ( (T[j ] - drag[j ] - m[j ] * grav[j ]) / m[j ] + (T[j - 1] - drag[j - 1] - m[j - 1] * grav[j - 1]) / m[j - 1] ) ) # m\u0026#39; = -T/c # Rectangular integration # @NLconstraint(rocket, m[j] == m[j - 1] - Δt * T[j - 1] / c) # Trapezoidal integration @NLconstraint(rocket, m[j] == m[j - 1] - 0.5 * Δt * (T[j] + T[j-1]) / c) end これまでに設計したモデルが完成したので、最適解を求める。\nprintln(\u0026#34;Solving...\u0026#34;) status = optimize!(rocket) Display results #  println(\u0026#34;Max height: \u0026#34;, objective_value(rocket)) Max height: 1.0128340648308016 可視化\nfunction my_plot(y, ylabel) return Plots.plot( (1:n) * value.(Δt), value.(y)[:]; xlabel = \u0026#34;Time (s)\u0026#34;, ylabel = ylabel, ) end Plots.plot( my_plot(h, \u0026#34;Altitude\u0026#34;), my_plot(m, \u0026#34;Mass\u0026#34;), my_plot(v, \u0026#34;Velocity\u0026#34;), my_plot(T, \u0026#34;Thrust\u0026#34;); layout = (2, 2), legend = false, margin = 1Plots.cm, )  "}),a.add({id:5,href:'/docs/opt_100/maxflow/',title:"最大流問題",section:"Opt 100",content:"最大流問題 #  using Cairo using Colors using Compose using GraphPlot using LightGraphs using LightGraphsFlows using SimpleWeightedGraphs const lg = LightGraphs 最大流問題 #  次に考えるネットワーク上の最適化問題は、最大流問題である。\nあなたは富士山を統括する大名だ。 いま、あなたは猛暑で苦しんでいる江戸の庶民にできるだけたくさんの富士山名物の氷を送ろうと思っている。 氷を運ぶには特別な飛脚を使う必要があるので、地点間の移動可能量には限りがあり、その上限は以下のようになっている。 さて、どのように氷を運べば最も多くの氷を江戸の庶民に運ぶことができるだろうか。\nfunction generate_digraph(plot_flag::Bool=false, file_name::String=\u0026#34;digraph.png\u0026#34;) G = SimpleWeightedDiGraph(5) capacity = Dict((1, 2) =\u0026gt; 5, (1, 3) =\u0026gt; 8, (2, 5) =\u0026gt; 8, (3, 2) =\u0026gt; 2, (3, 4) =\u0026gt; 5, (4, 5) =\u0026gt; 6) for (e, w) in capacity add_edge!(G, e[1], e[2], w) end pos = [0. 1.; 1. 0.; 1. 2.; 2. 2.; 2. 0.] locs_x = pos[:, 1] locs_y = pos[:, 2] if plot_flag draw( PNG(file_name, 13cm, 8cm), gplot(G, locs_x, locs_y, nodelabel=1:nv(G), edgelabel=[e.weight for e in edges(G)]) ) end return G end G = generate_digraph(true);  最大流問題は、最短路問題と並んでネットワーク理論もっとも基本的な問題のひとつであり、水や車などをネットワーク上に流すという直接的な応用の他にも、スケジューリングから分子生物学にいたるまで多種多様な応用をもつ。\n最短路問題の目的は、ある尺度を最適にする「パス（路）」を求めることであったが、最大流問題や最小費用流問題の目的は、ある尺度を最適にする「フロー(流)」を求めることである。\n最大流問題を、グラフ・ネットワークの用語を使って定義しておこう。\n最大流問題（maximum flow problem） #     \\(n\\)  個の点から構成される点集合  \\(V\\)  および  \\(m\\)  本の枝から構成される枝集合  \\(E\\)  、  \\(V\\)  と  \\(E\\)  から成る有向グラフ  \\(G=(V,E)\\)  、 枝上に定義される非負の容量関数  \\(u: E \\rightarrow \\mathbf{R}_\u0026#43;\\)  、 始点  \\(s \\in V\\)  および終点  \\(t \\in V\\)  が与えられたとき、始点  \\(s\\)  から終点  \\(t\\)  までの「フロー」で、その量が最大になるものを求めよ。\n上の問題の定義を完結させるためには、「フロー」を厳密に定義する必要がある。\nフロー（flow）とは枝上に定義された実数値関数  \\(x: E \\rightarrow \\mathbf{R}\\)  で、以下の性質を満たすものを指す。\n フロー整合条件:  \\[\\sum_{j: ji \\in E} x_{ji} - \\sum_{j: ij \\in E} x_{ij} =0 \\ \\ \\ \\forall i \\in V \\setminus \\{s,t\\}\\]   容量制約と非負制約:  \\[0 \\leq x_{e} \\leq u_{e} \\ \\ \\ \\forall e \\in E\\]    各点  \\(i \\in V\\)  に対して関数  \\(f_x(i)\\)  を\n \\[f_x(i) = \\sum_{j: ji \\in E} x_{ji} - \\sum_{j: ij \\in E} x_{ij}\\]  と定義する。 これはフローを表すベクトル  \\(x\\)  によって定まる量であり、点  \\(i\\)  に入ってきた量  \\(\\sum_{j: ji \\in E} x_{ji}\\)  から出ていく量  \\(\\sum_{j: ij \\in E} x_{ij}\\)  を減じた値であるので、フロー  \\(x\\)  の点  \\(i\\)  における超過(excess)とよばれる。\n最大の値をもつフロー  \\(x\\)  を求めることが最大流問題の目的である。 最大流問題を線形最適化問題として定式化すると以下のようになる。  \\[\\begin{array}{l l} maximize \u0026amp; f_x(t) \\\\ s.t. \u0026amp; f_x(i) =0 \\ \\ \\ \\forall i \\in V \\setminus \\{s,t\\} \\\\ \u0026amp; 0 \\leq x_{e} \\leq u_{e} \\ \\ \\ \\forall e \\in E \\end{array}\\]  上記の最適化をJuliaでは LightGraphsFlows.jl で解く。 LightGraphsFlows.jl ではいくつかの最大流問題を解くためのアルゴリズムを提供しており、 maximum_flow 関数に渡すことで最適化を行う。 デフォルトでは PushRelabelAlgorithm が採用される。 さらにpythonのnetworkxが提供している maximum_flow 関数ではグラフオブジェクト自体がエッジの重みを持つことを前提としているため、capacityは指定しなくても良いが、 LightGraphsFlows.jl の maximum_flow 関数では明示的にcapacityを渡す仕様となっている。\nvalue, flow = maximum_flow(DiGraph(G), 1, 5, weights(G)) println(\u0026#34;value: $value\u0026#34;) println(\u0026#34;flow: \\n$flow\u0026#34;) returnされるオブジェクトの内容はnetworkxと同様のものであり、下記のように出力される。\nvalue: 12.0 flow: ⋅ 5.0 7.0 ⋅ ⋅ -5.0 ⋅ -2.0 ⋅ 7.0 -7.0 2.0 ⋅ 5.0 ⋅ ⋅ ⋅ -5.0 ⋅ 5.0 ⋅ -7.0 ⋅ -5.0 ⋅ 上記、最大流問題を解いた結果を可視化すると\nnew_G = SimpleWeightedDiGraph(flow.*(flow .\u0026gt; 0)) # flow.*(flow .\u0026gt; 0)はedgeのダブルカウントを防ぐ処理。 pos = [0. 1.; 1. 0.; 1. 2.; 2. 2.; 2. 0.] locs_x = pos[:, 1] locs_y = pos[:, 2] draw( PNG(\u0026#34;maxflow_graph.png\u0026#34;, 13cm, 8cm), gplot(new_G, locs_x, locs_y, nodelabel=1:nv(new_G), edgelabel=[e.weight for e in edges(new_G)]) )  となる。\n最小カット問題 #  始点  \\(s\\)  を含み、終点  \\(t\\)  を含まない点の部分集合  \\(S\\)  を考える。  \\(S\\)  から出て  \\(S\\)  以外の点に向かう枝の集合をカット(cut)とよび、  \\[\\delta(S) = \\{ (u,v)~|~(u,v) \\in E, u \\in S, v \\not\\in S \\}\\]  と書くことにする。カットに含まれる枝の容量の合計をカット容量とよぶ。\n始点  \\(s\\)  から終点  \\(t\\)  までは、(どんなにがんばっても)カット容量より多くのフローを流すことはできないので、カット容量はフロー量の上界を与えることがわかる。\nすべての可能なカットに対して、カット容量を最小にするものを求める問題は、最小カット問題(minimum cut problem)とよばれる。\n最大流問題と最小カット問題には、以下の関係（最大フロー・最小カット定理）がある。\n最大のフロー量と最小のカット容量は一致する。\nLightGraphsFlows.jl が用意している最小カット問題を解くための関数では最大フロー問題を解くための関数とは異なり、デフォルトで採用されるアルゴリズムがない。 そのため下記のように明示的にアルゴリズムを渡す必要がある。\npart₁, part₂, value = LightGraphsFlows.mincut(DiGraph(G), 1, 5, weights(G), EdmondsKarpAlgorithm()) println(\u0026#34;part₁: $part₁\u0026#34;) println(\u0026#34;part₂: $part₂\u0026#34;) println(\u0026#34;value: $value\u0026#34;) 出力結果としては\npart₁: [1, 3] part₂: [2, 4, 5] value: 12.0 となる。 確かに本ページの最初のフロー図にて 1, 5 をそれぞれ含むノードの組み合わせ集合の中で [1, 3] と [2, 4, 5] の集合をカットするフローが最小フローとなっている。\nまた LightGraphsFlows.jl の maximum_flow 関数や mincut 関数は AbstractFlowAlgorithm の下部構造を引数として渡すことで最適化アルゴリズムを切り替えられる。 その最適解を得るためのアルゴリズムをいくつか用意しているものの、現在のところドキュメントに記載がない。 下記のソースコードをから読み取って切り替えを試してもらいたい。\n LightGraphsFlows.jl の最下部にてexportしている maxmun_flow.jl にて AbstractFlowAlgorithm やその他のアルゴリズムが定義されている README.md 内でいくつかのアルゴリズムのスイッチ方法の例がある  現在確認できるアルゴリズムは下記の通りである。\n EdmondsKarpAlgorithm DinicAlgorithm BoykovKolmogorovAlgorithm PushRelabelAlgorithm KishimotoAlgorithm ExtendedMultirouteFlowAlgorithm  基本的にはMax flow algorighms内で紹介されている関数と対応はしていると見られる。\n"}),a.add({id:6,href:'/docs/opt_100/k_shortest_paths/',title:"最短路の列挙",section:"Opt 100",content:"最短経路の列挙 #  using Cairo using Colors using Compose using GraphPlot using GraphRecipes using LightGraphs using MetaGraphs using SimpleWeightedGraphs 第k最短路 #  LightGraphs.jl にYenの第   \\(k\\)  最短路のアルゴリズムが含まれている。これは、最短路を短い（費用の小さい）順に列挙してくれる。\nJin Y. Yen, “Finding the K Shortest Loopless Paths in a Network”, Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716.\nまずは2次元格子状のネットワークを構築する。\nfunction generate_grid(node_num_array::Union{Tuple{Int,Real},Array{Int,1}}, random_range::Union{UnitRange{\u0026lt;:Real}, Array{\u0026lt;:Real,1}}=1:10, plot_flag::Bool=false, file_name::String=\u0026#34;grid.png\u0026#34;) @assert length(node_num_array) == 2 grid_graph = grid(node_num_array) # gridで格子状のエッジを構築 g = SimpleWeightedGraph(nv(grid_graph)) # 重み付きエッジのグラフをgrid_graphのノードの個数構築 edge_weight = rand(random_range, grid_graph.ne) # 予め乱数でエッジの重みを作成 for (num, e) in enumerate(edges(grid_graph)) add_edge!(g, e.src, e.dst, edge_weight[num]) end locs_x = Array{Float64, 1}( vcat([i for i in 1:node_num_array[1], j in 1:node_num_array[2]]...)) locs_y = Array{Float64, 1}( vcat([j for i in 1:node_num_array[1], j in 1:node_num_array[2]]...)) if plot_flag draw( PNG(file_name, 10cm, 10cm), gplot(SimpleGraph(g), # weightgraphは直接gplotに渡せないためSimpleGraph型にキャストする locs_x, locs_y, nodelabel=1:nv(g), edgelabel=[e.weight for e in ordered_edges(g)]) ) end return g end # edgeの並びを整理する関数 function ordered_edges(graph::LightGraphs.AbstractGraph) edge_dict = Dict{Tuple{Int,Real}, Any}() for e in edges(graph) edge_dict[(src(e), dst(e))] = e end return values(sort(edge_dict)) end const node_num_array = [5, 5] const g = generate_grid(node_num_array, 1:10, true);  ここで LightGraph.jl が用意している edges 関数が返す順序とグラフ可視化のための gplot 関数の edgelabel に渡す順序が一致しないことに注意する。 edgelabel ではlexicographic orderingに従う (https://github.com/JuliaGraphs/GraphPlot.jl/issues/70)。 そのため、ここではラベルの順序を一時的に整理する orderd_edges 関数を用意した。\nYenのアルゴリズムは下記のように呼び出す。\nyen_k_shortest_paths(g, 1, 25) 出力としては\nLightGraphs.YenState{Float64, Int64}([33.0], [[1, 2, 7, 12, 17, 18, 19, 20, 25]]) と、最短ルートを1つ出力します。第 \\(k\\)  最短経路を出力するには\nk = 5; yen_state = yen_k_shortest_paths(g, 1, 25, weights(g), k); for (p, d) in zip(yen_state.paths, yen_state.dists) println(\u0026#34;path: $p, dists: $d\u0026#34;) end のように実行する。しかし、現在のところ何点か yen_k_shortest_paths 関数にはバグが存在する。実際、上記の実行結果では同じエッジがk回出力されてしまう。\npath: [1, 2, 7, 12, 17, 18, 19, 20, 25], dists: 33.0 path: [1, 2, 7, 12, 17, 18, 19, 20, 25], dists: 33.0 path: [1, 2, 7, 12, 17, 18, 19, 20, 25], dists: 33.0 path: [1, 2, 7, 12, 17, 18, 19, 20, 25], dists: 33.0 path: [1, 2, 7, 12, 17, 18, 19, 20, 25], dists: 33.0 同様のバグ(リンク)が報告されている。同じ費用の経路がある場合に2度同じ経路が出力されてしまうというバグである。これらは LightGraphs.jl のサブモジュールである SimpleWeightedGraphs.jl の rem_edge! のバグ(リンク)に起因する。\n今回の原因となっている SimpleWeightedgraphs を避けて対応すれば良いので、以下のように実行する。\nk = 5; yen_state = yen_k_shortest_paths(SimpleGraph(g), 1, 25, weights(g), k); for (p, d) in zip(yen_state.paths, yen_state.dists) println(\u0026#34;path: $p, dists: $d\u0026#34;) end 下記のように期待する出力が得られる。\npath: [1, 2, 7, 12, 17, 18, 19, 20, 25], dists: 33.0 path: [1, 2, 3, 4, 9, 14, 19, 20, 25], dists: 35.0 path: [1, 2, 7, 12, 13, 18, 19, 20, 25], dists: 35.0 path: [1, 2, 7, 12, 17, 18, 23, 24, 25], dists: 36.0 path: [1, 2, 7, 12, 17, 18, 19, 24, 25], dists: 37.0 同様に有効グラフの場合にも SimpleDiGraph でキャストして実行すれば良い。型に応じて多重ディスパッチで対応すれば yen_k_shortest_paths 関数のバグは修正できるはずである。 可視化と最短経路を同時に得るため、下記の関数を定義する。\nfunction grid_yen_shortest_path(graph::SimpleWeightedGraph, node_num_array::Union{Tuple{Int,Real},Array{Int,1}}, source::Int, target::Int; k_path::Int=1, plot_flag::Bool=false, file_name::String=\u0026#34;grid_shortest_path.png\u0026#34;) @assert length(node_num_array) == 2 shortest_path = yen_k_shortest_paths(SimpleGraph(graph), source, target, weights(graph), k_path) dists = shortest_path.dists; paths = shortest_path.paths; @assert length(paths) \u0026gt;= k_path locs_x = Array{Float64, 1}( vcat([i for i in 1:node_num_array[1], j in 1:node_num_array[2]]...)) locs_y = Array{Float64, 1}( vcat([j for i in 1:node_num_array[1], j in 1:node_num_array[2]]...)) colors = [colorant\u0026#34;lightgray\u0026#34; for i in 1:ne(graph)]; node_piar = Set{Set}() for (num, (i, j)) in enumerate(zip(paths[k_path][begin:end-1], paths[k_path][begin+1:end])) push!(node_piar, Set([i, j])) end if plot_flag for (num, e) in enumerate(ordered_edges(graph)) if Set([src(e), dst(e)]) in node_piar colors[num] = colorant\u0026#34;orange\u0026#34; end end draw( PNG(file_name, 10cm, 10cm), gplot(SimpleGraph(graph), locs_x, locs_y, nodelabel=1:prod(node_num_array), edgestrokec=colors, edgelabel=[e.weight for e in ordered_edges(graph)]) ) end return dists, paths end d, p = grid_yen_shortest_path(g, node_num_array, 1, nv(g), k_path=1, plot_flag=true)  この際の距離 d は 33.0 であった。さらに、第2最短経路の場合には下記のように実行する。\nd, p = grid_yen_shortest_path(g, node_num_array, 1, nv(g), k_path=2, plot_flag=true, file_name=\u0026#34;grid_shortest_path_second.png\u0026#34;)  この際の距離 d[end] は 35.0 であった。\n無向パス（閉路，森など）の列挙 #  現在のところGraphillionのようにパスの列挙をする関数は用意されていないようである。 一方、 networkx の all_simple_paths に対応する関数のプルリクが挙がっている。\nhttps://github.com/JuliaGraphs/LightGraphs.jl/pull/1540\nもし all_simple_paths が実装されれば対応する処理ができると思われる。\n# !!実装されていない関数であり、下記の関数は動きません!! function all_paths_count(g::AbstractGraph, source::Int) c = 0 for i in 1:nv(g) if source == i continue end c += length(all_simple_paths(g, source, i)) end return c / 2 end 同様に、最長経路に関する関数も現在のところ用意されていない。\n閉路の列挙 #  閉路の列挙には simplecycles_limited_length 関数を用いる。 まず閉路の列挙のため、新規でグラフを生成する。\nfunction generate_random_complete_graph(n::Int, plot_flag::Bool=false, file_name::String=\u0026#34;random_complete_graph.png\u0026#34;) x = Dict(i =\u0026gt; 100*rand(Float64) for i in 1:n) y = Dict(i =\u0026gt; 100*rand(Float64) for i in 1:n) G = SimpleWeightedGraph(n) for i in 1:n p₁ = Point(x[i], y[i]) for j in 1:n p₂ = Point(x[j], y[j]) if j \u0026gt; i d = distance(p₁, p₂) add_edge!(G, i, j, d) end end end locs_x = collect(values(x)) locs_y = collect(values(y)) if plot_flag draw( PNG(file_name, 10cm, 10cm), gplot(SimpleGraph(G), # weightgraphは直接gplotに渡せない locs_x, locs_y, nodelabel=1:nv(G)) ) end return G, locs_x, locs_y end struct Point x::Float64 y::Float64 end function distance(p₁::Point, p₂::Point) sqrt((p₁.x - p₂.x)^2 + (p₁.y - p₂.y)^2) end G, locs_x, locs_y = generate_random_complete_graph(10, true);  simplecycles_limited_length 関数は下記のように利用する。\nsimplecycles_limited_length(G, 3)   出力結果 ↕  285-element Vector{Vector{Int64}}: [1, 2] [1, 2, 3] [1, 2, 4] [1, 2, 5] [1, 2, 6] [1, 2, 7] [1, 2, 8] [1, 2, 9] [1, 2, 10] [1, 3] [1, 3, 2] [1, 3, 4] [1, 3, 5] [1, 3, 6] [1, 3, 7] [1, 3, 8] [1, 3, 9] [1, 3, 10] [1, 4] [1, 4, 2] [1, 4, 3] [1, 4, 5] [1, 4, 6] [1, 4, 7] [1, 4, 8] [1, 4, 9] ⋮ [6, 8, 7] [6, 8, 9] [6, 8, 10] [6, 9] [6, 9, 7] [6, 9, 8] [6, 9, 10] [6, 10] [6, 10, 7] [6, 10, 8] [6, 10, 9] [7, 8] [7, 8, 9] [7, 8, 10] [7, 9] [7, 9, 8] [7, 9, 10] [7, 10] [7, 10, 8] [7, 10, 9] [8, 9] [8, 9, 10] [8, 10] [8, 10, 9] [9, 10]     となる。第二引数以下で閉路が形成されるパスが列挙される。今回の場合、2または3ステップの閉路が列挙された。 完全グラフであるため、  \\[{}_{10}C_{2} \u0026#43; \\sum_{k=1}^8 {}_{10-k}P_2 = \\frac{10\\cdot 9}{2\\cdot 1} \u0026#43; \\sum_{k=1}^8 k (k\u0026#43;1)\\\\ = 45 \u0026#43; \\sum_{k=1}^8 k^2 \u0026#43; \\sum_{k=1}^8 k\\\\ = 45 \u0026#43; \\frac{1}{6} n(n\u0026#43;1)(2n \u0026#43; 1)|_{n=8} \u0026#43; \\frac{1}{2} n (n\u0026#43;1)|_{n=8}\\\\ = 285\\]  であり、上記の出力数と一致している。\nsimplecycles_limited_length を用いて閉路を検出する関数を用意する。\nfunction detect_cycle(g::AbstractGraph, source::Int, len::Int) [i for i in simplecycles_limited_length(g, len) if length(i) \u0026gt; len-1 \u0026amp;\u0026amp; i[1] == source] end 閉路を検出し、同時に可視化もまとめた関数を下記のように用意した。\nfunction cycle_plot(G::AbstractGraph, source::Int, len::Int, locs_x::Vector, locs_y::Vector, file_name::String=\u0026#34;cycle_plot.png\u0026#34;) paths = detect_cycle(G, source, len) path = paths[rand(1:length(paths))] # 1つサンプル node_piar = Set{Set}() for (num, (i, j)) in enumerate(zip(path[begin:end-1], path[begin+1:end])) push!(node_piar, Set([i, j])) end node_piar[end] = (path[begin], path[end]) colors = [colorant\u0026#34;lightgray\u0026#34; for i in 1:ne(G)] for (num, e) in enumerate(ordered_edges(G)) if Set([src(e), dst(e)]) in node_piar colors[num] = colorant\u0026#34;orange\u0026#34; end end draw( PNG(file_name, 10cm, 10cm), gplot(SimpleGraph(G), # weightgraphは直接gplotに渡せない locs_x, locs_y, edgestrokec=colors, nodelabel=1:nv(G)) ) end 実行結果は下記の通りである。\ncycle_plot(G, 1, 4, locs_x, locs_y)  Hamilton閉路 #  現在のところHamilton閉路を見つけるパッケージは作られていない。\n多目的最短路問題 #  費用と時間の2つの重みをもつグラフに対して、意思決定者にとって便利な複数のパスを示す問題を考える。 これは、多目的最適化問題になる。\nまず、多目的最適化の基礎と用語について述べる。\n以下に定義される  \\(m\\)  個の目的をもつ多目的最適化問題を対象とする。\n解の集合  \\(X\\)  ならびに  \\(X\\)  から  \\(m\\)  次元の実数ベクトル全体への写像  \\(f: X \\rightarrow \\mathbf{R}^m\\)  が与えられている。 ベクトル  \\(f\\)  を目的関数ベクトルとよび、その第  \\(i\\)  要素を  \\(f_i\\)  と書く。 ここでは、ベクトル  \\(f\\)  を「何らかの意味」で最小にする解（の集合）を求めることを目的とする。\n2つの目的関数ベクトル  \\(f,g\\in \\mathbf{R}^m\\)  に対して、  \\(f\\)  と  \\(g\\)  が同じでなく、かつベクトルのすべての要素に対して  \\(f\\)  の要素が  \\(g\\)  の要素以下であるとき、ベクトル  \\(f\\)  がベクトル  \\(g\\)  に優越しているとよび、  \\(f \\prec g\\)  と記す。\nすなわち、順序  \\(\\prec\\)  を以下のように定義する。  \\[f \\prec g \\Leftrightarrow f \\neq g, f_i \\leq g_i \\ \\ \\ \\forall i\\]  たとえば、2つのベクトル  \\(f=(2,5,4)f=(2,5,4)\\)  と  \\(g=(2,6,8)g=(2,6,8)\\)  に対しては、第1要素は同じであるが、第2,3要素に対しては  \\(g\\)  の方が大きいので  \\(f \\prec g\\)  である。\n2つの解  \\(x,y\\)  に対して、 \\(f(x) \\prec f(y)\\)  のとき、解  \\(x\\)  は解  \\(y\\)  に優越していると呼ぶ。 以下の条件を満たすとき、  \\(x\\)  は 非劣解 (nondominated solution) もしくは Pareto最適解 (Pareto optimal solution)と呼ばれる。  \\[f(y) \\prec f(x) を満たす解 y \\in X は存在しない\\]  多目的最適化問題の目的は、すべての非劣解(Pareto最適解)の集合を求めることである。 非劣解の集合から構成される境界は、 金融工学における株の構成比を決める問題（ポートフォリオ理論）では有効フロンティア(efficient frontier)と呼ばれる。 ポートフォリオ理論のように目的関数が凸関数である場合には、有効フロンティアは凸関数になるが、一般には非劣解を繋いだものは凸になるとは限らない。\n非劣解の総数は非常に大きくなる可能性がある。 そのため、実際にはすべての非劣解を列挙するのではなく、 意思決定者の好みにあった少数の非劣解を選択して示すことが重要になる。\n最も単純なスカラー化は複数の目的関数を適当な比率を乗じて 足し合わせることである。\n \\(m\\)  次元の目的関数ベクトルは、  \\(m\\)  次元ベクトル  \\(\\alpha\\)  を用いてスカラー化できる。 通常、パラメータ  \\(\\alpha\\)  は  \\[\\sum_{i=1}^m \\alpha_i =1\\]  を満たすように正規化しておく。\nこの  \\(\\alpha\\)  を用いて重み付きの和をとることにより、 以下のような単一の（スカラー化された）目的関数  \\(f_{\\alpha}\\)  に変換できる。  \\[f_{\\alpha}(x)= \\sum_{i=1}^m \\alpha_i f_i(x)\\]  これを2目的の最短路問題に適用してみよう。格子グラフの枝に２つの重み（costとtime）を定義して、スカラー化を用いて、有効フロンティアを描画する。\nまずは元サイトと同様のプロセスで格子状のグラフを作成する。各エッジに :cost と :time の属性を付与する。\nconst m, n = 100, 100; const lb, ub = 1, 100; mg = MetaGraph(grid([m, n])); for e in edges(mg) set_prop!(mg, e, :cost, rand(lb:ub)) set_prop!(mg, e, :time, 100/get_prop(mg, e, :cost)) end 最短経路を解くようにする\nx, y = Vector{Int}(), Vector{Float64}() for k in 0:99 α = 0.01 * k for e in edges(mg) set_prop!(mg, e, :weight, α * get_prop(mg, e, :cost) + (1 - α) * get_prop(mg, e, :time)) end dijk = dijkstra_shortest_paths(mg, 1, weights(mg)) cost, time = 0, 0.0 j = 1 for i in enumerate_paths(dijk, m * n)[begin+1:end] cost += get_prop(mg, Edge(j, i), :cost) time += get_prop(mg, Edge(j, i), :time) j = i end push!(x, cost) push!(y, time) end 可視化\nsavefig(plot(x, y, line=(3, 0.6, :green), marker=(:circle, 5, 0.8, Plots.stroke(0), :green), legend=false), \u0026#34;efficient_frontier.png\u0026#34;)  時間を測定するため関数化する。\nusing BenchmarkTools function ef(input_graph::MetaGraph) x, y = Vector{Int}(), Vector{Float64}() for k in 0:99 α = 0.01 * k for e in edges(input_graph) set_prop!(input_graph, e, :weight, α * get_prop(input_graph, e, :cost) + (1 - α) * get_prop(input_graph, e, :time)) end dijk = dijkstra_shortest_paths(input_graph, 1, weights(input_graph)) cost::Int = 0 time::Float64 = 0.0 j = 1 for i in enumerate_paths(dijk, m * n)[begin+1:end] cost += get_prop(input_graph, Edge(j, i), :cost) time += get_prop(input_graph, Edge(j, i), :time) j = i end push!(x, cost) push!(y, time) end return x, y end @benchmark ef(mg) 計測結果は\nBenchmarkTools.Trial: memory estimate: 3.69 GiB allocs estimate: 37869799 -------------- minimum time: 4.847 s (12.67% GC) median time: 4.921 s (13.22% GC) mean time: 4.921 s (13.22% GC) maximum time: 4.994 s (13.76% GC) -------------- samples: 2 evals/sample: 1 pythonでの時間の測定コードは下記となる。\nfrom time import time as t start = t() x, y =[],[] for k in range(100): alpha = 0.01* k for (i,j) in G.edges(): G[i][j][\u0026#34;weight\u0026#34;] = alpha*G[i][j][\u0026#34;cost\u0026#34;]+ (1-alpha)*G[i][j][\u0026#34;time\u0026#34;] pred, distance = nx.dijkstra_predecessor_and_distance(G, source=(0,0)) #print(\u0026#34;minimum cost=\u0026#34;, distance[m-1,n-1]) j = (m-1,n-1) cost = time = 0 while i != (0,0): i = pred[j][0] cost += G[i][j][\u0026#34;cost\u0026#34;] time += G[i][j][\u0026#34;time\u0026#34;] j = i #print(cost,time) x.append(cost) y.append(time) process_time = t() - start print(process_time) 測定結果は\n28.481345653533936 となった。およそ5倍と非常にJuliaのdijkstraアルゴリズムが高速であることがわかった。\nすべての単純パスを列挙するアルゴリズム #  上記にもあるように、現在のところ LightGraphs.jl では all_simple_paths に対応する関数のプルリクが挙がっている。\n"}),a.add({id:7,href:'/docs/opt_100/',title:"Opt 100",section:"Docs",content:"Juliaで数理最適化 100問 #  Juliaで数理最適化100問を再構成する。\nTable of Contents #    最大流問題   最大流問題に対する定式化とアルゴリズム   最短路の列挙   第k最短路と LightGraph.jl による無向グラフの列挙と多目的最短路   "}),a.add({id:8,href:'/docs/jump/',title:"JuMPチュートリアル",section:"Docs",content:"JuMP.jl のチュートリアル #  Juliaの数理最適化パッケージである JuMP.jl の使い方およびチュートリアルを紹介していきます。\nTable of Contents #    Getting Started W Jump   JuMPのチュートリアルを見ながら簡単なビンパッキング問題を解いたものを紹介します。   N-Queens   Nクイーン問題を最適化問題としてときます   The Diet Problem   線形最適化によって、栄養基準を満たす食事を求めるチュートリアルです。   Sudoku   数独のルールを数理最適化とみなし解くチュートリアルです   Rocket Control   非線形最適化を用いてロケット制御問題を解くチュートリアルです   "})})()